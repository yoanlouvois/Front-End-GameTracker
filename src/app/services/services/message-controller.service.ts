/* tslint:disable */
/* eslint-disable */
/* Code generated by ng-openapi-gen DO NOT EDIT. */

import { HttpClient, HttpContext } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

import { BaseService } from '../base-service';
import { ApiConfiguration } from '../api-configuration';
import { StrictHttpResponse } from '../strict-http-response';

import { countUnreadMessages } from '../fn/message-controller/count-unread-messages';
import { CountUnreadMessages$Params } from '../fn/message-controller/count-unread-messages';
import { deleteConversation } from '../fn/message-controller/delete-conversation';
import { DeleteConversation$Params } from '../fn/message-controller/delete-conversation';
import { deleteMessage } from '../fn/message-controller/delete-message';
import { DeleteMessage$Params } from '../fn/message-controller/delete-message';
import { encryptMessageContent } from '../fn/message-controller/encrypt-message-content';
import { EncryptMessageContent$Params } from '../fn/message-controller/encrypt-message-content';
import { getConversation } from '../fn/message-controller/get-conversation';
import { GetConversation$Params } from '../fn/message-controller/get-conversation';
import { getMessageById } from '../fn/message-controller/get-message-by-id';
import { GetMessageById$Params } from '../fn/message-controller/get-message-by-id';
import { getMessageHistory } from '../fn/message-controller/get-message-history';
import { GetMessageHistory$Params } from '../fn/message-controller/get-message-history';
import { getMessagesByReceiver } from '../fn/message-controller/get-messages-by-receiver';
import { GetMessagesByReceiver$Params } from '../fn/message-controller/get-messages-by-receiver';
import { getMessagesBySender } from '../fn/message-controller/get-messages-by-sender';
import { GetMessagesBySender$Params } from '../fn/message-controller/get-messages-by-sender';
import { getRecentMessages } from '../fn/message-controller/get-recent-messages';
import { GetRecentMessages$Params } from '../fn/message-controller/get-recent-messages';
import { markAsRead1 } from '../fn/message-controller/mark-as-read-1';
import { MarkAsRead1$Params } from '../fn/message-controller/mark-as-read-1';
import { markConversationAsRead } from '../fn/message-controller/mark-conversation-as-read';
import { MarkConversationAsRead$Params } from '../fn/message-controller/mark-conversation-as-read';
import { MessageDto } from '../models/message-dto';
import { PageMessageDto } from '../models/page-message-dto';
import { searchMessages } from '../fn/message-controller/search-messages';
import { SearchMessages$Params } from '../fn/message-controller/search-messages';
import { sendMessage } from '../fn/message-controller/send-message';
import { SendMessage$Params } from '../fn/message-controller/send-message';
import { updateMessageContent } from '../fn/message-controller/update-message-content';
import { UpdateMessageContent$Params } from '../fn/message-controller/update-message-content';

@Injectable({ providedIn: 'root' })
export class MessageControllerService extends BaseService {
  constructor(config: ApiConfiguration, http: HttpClient) {
    super(config, http);
  }

  /** Path part for operation `updateMessageContent()` */
  static readonly UpdateMessageContentPath = '/gametracker/v1/message/{messageId}/update';

  /**
   * Mettre à jour le contenu d'un message.
   *
   * Mettre à jour le contenu d'un message
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `updateMessageContent()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  updateMessageContent$Response(params: UpdateMessageContent$Params, context?: HttpContext): Observable<StrictHttpResponse<MessageDto>> {
    return updateMessageContent(this.http, this.rootUrl, params, context);
  }

  /**
   * Mettre à jour le contenu d'un message.
   *
   * Mettre à jour le contenu d'un message
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `updateMessageContent$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  updateMessageContent(params: UpdateMessageContent$Params, context?: HttpContext): Observable<MessageDto> {
    return this.updateMessageContent$Response(params, context).pipe(
      map((r: StrictHttpResponse<MessageDto>): MessageDto => r.body)
    );
  }

  /** Path part for operation `markAsRead1()` */
  static readonly MarkAsRead1Path = '/gametracker/v1/message/{messageId}/mark-read';

  /**
   * Marquer un message comme lu.
   *
   * Marquer un message comme lu
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `markAsRead1()` instead.
   *
   * This method doesn't expect any request body.
   */
  markAsRead1$Response(params: MarkAsRead1$Params, context?: HttpContext): Observable<StrictHttpResponse<MessageDto>> {
    return markAsRead1(this.http, this.rootUrl, params, context);
  }

  /**
   * Marquer un message comme lu.
   *
   * Marquer un message comme lu
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `markAsRead1$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  markAsRead1(params: MarkAsRead1$Params, context?: HttpContext): Observable<MessageDto> {
    return this.markAsRead1$Response(params, context).pipe(
      map((r: StrictHttpResponse<MessageDto>): MessageDto => r.body)
    );
  }

  /** Path part for operation `encryptMessageContent()` */
  static readonly EncryptMessageContentPath = '/gametracker/v1/message/{messageId}/encrypt';

  /**
   * Chiffrer le contenu d'un message.
   *
   * Chiffrer le contenu d'un message
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `encryptMessageContent()` instead.
   *
   * This method doesn't expect any request body.
   */
  encryptMessageContent$Response(params: EncryptMessageContent$Params, context?: HttpContext): Observable<StrictHttpResponse<void>> {
    return encryptMessageContent(this.http, this.rootUrl, params, context);
  }

  /**
   * Chiffrer le contenu d'un message.
   *
   * Chiffrer le contenu d'un message
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `encryptMessageContent$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  encryptMessageContent(params: EncryptMessageContent$Params, context?: HttpContext): Observable<void> {
    return this.encryptMessageContent$Response(params, context).pipe(
      map((r: StrictHttpResponse<void>): void => r.body)
    );
  }

  /** Path part for operation `markConversationAsRead()` */
  static readonly MarkConversationAsReadPath = '/gametracker/v1/message/conversation/{user1Id}/{user2Id}/mark-read';

  /**
   * Marquer une conversation comme lue.
   *
   * Marquer une conversation comme lue
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `markConversationAsRead()` instead.
   *
   * This method doesn't expect any request body.
   */
  markConversationAsRead$Response(params: MarkConversationAsRead$Params, context?: HttpContext): Observable<StrictHttpResponse<void>> {
    return markConversationAsRead(this.http, this.rootUrl, params, context);
  }

  /**
   * Marquer une conversation comme lue.
   *
   * Marquer une conversation comme lue
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `markConversationAsRead$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  markConversationAsRead(params: MarkConversationAsRead$Params, context?: HttpContext): Observable<void> {
    return this.markConversationAsRead$Response(params, context).pipe(
      map((r: StrictHttpResponse<void>): void => r.body)
    );
  }

  /** Path part for operation `sendMessage()` */
  static readonly SendMessagePath = '/gametracker/v1/message/send';

  /**
   * Envoyer un message.
   *
   * Envoyer un message
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `sendMessage()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  sendMessage$Response(params: SendMessage$Params, context?: HttpContext): Observable<StrictHttpResponse<MessageDto>> {
    return sendMessage(this.http, this.rootUrl, params, context);
  }

  /**
   * Envoyer un message.
   *
   * Envoyer un message
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `sendMessage$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  sendMessage(params: SendMessage$Params, context?: HttpContext): Observable<MessageDto> {
    return this.sendMessage$Response(params, context).pipe(
      map((r: StrictHttpResponse<MessageDto>): MessageDto => r.body)
    );
  }

  /** Path part for operation `getMessageById()` */
  static readonly GetMessageByIdPath = '/gametracker/v1/message/{messageId}';

  /**
   * Récupérer un message par son ID.
   *
   * Récupérer un message par son ID
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getMessageById()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMessageById$Response(params: GetMessageById$Params, context?: HttpContext): Observable<StrictHttpResponse<MessageDto>> {
    return getMessageById(this.http, this.rootUrl, params, context);
  }

  /**
   * Récupérer un message par son ID.
   *
   * Récupérer un message par son ID
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getMessageById$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMessageById(params: GetMessageById$Params, context?: HttpContext): Observable<MessageDto> {
    return this.getMessageById$Response(params, context).pipe(
      map((r: StrictHttpResponse<MessageDto>): MessageDto => r.body)
    );
  }

  /** Path part for operation `deleteMessage()` */
  static readonly DeleteMessagePath = '/gametracker/v1/message/{messageId}';

  /**
   * Supprimer un message.
   *
   * Supprimer un message
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `deleteMessage()` instead.
   *
   * This method doesn't expect any request body.
   */
  deleteMessage$Response(params: DeleteMessage$Params, context?: HttpContext): Observable<StrictHttpResponse<void>> {
    return deleteMessage(this.http, this.rootUrl, params, context);
  }

  /**
   * Supprimer un message.
   *
   * Supprimer un message
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `deleteMessage$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  deleteMessage(params: DeleteMessage$Params, context?: HttpContext): Observable<void> {
    return this.deleteMessage$Response(params, context).pipe(
      map((r: StrictHttpResponse<void>): void => r.body)
    );
  }

  /** Path part for operation `countUnreadMessages()` */
  static readonly CountUnreadMessagesPath = '/gametracker/v1/message/unread/count/{userId}';

  /**
   * Compter le nombre de messages non lus pour un utilisateur.
   *
   * Compter le nombre de messages non lus pour un utilisateur
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `countUnreadMessages()` instead.
   *
   * This method doesn't expect any request body.
   */
  countUnreadMessages$Response(params: CountUnreadMessages$Params, context?: HttpContext): Observable<StrictHttpResponse<number>> {
    return countUnreadMessages(this.http, this.rootUrl, params, context);
  }

  /**
   * Compter le nombre de messages non lus pour un utilisateur.
   *
   * Compter le nombre de messages non lus pour un utilisateur
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `countUnreadMessages$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  countUnreadMessages(params: CountUnreadMessages$Params, context?: HttpContext): Observable<number> {
    return this.countUnreadMessages$Response(params, context).pipe(
      map((r: StrictHttpResponse<number>): number => r.body)
    );
  }

  /** Path part for operation `getMessagesBySender()` */
  static readonly GetMessagesBySenderPath = '/gametracker/v1/message/sender/{senderId}';

  /**
   * Récupérer les messages envoyés par un utilisateur.
   *
   * Récupérer les messages envoyés par un utilisateur
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getMessagesBySender()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMessagesBySender$Response(params: GetMessagesBySender$Params, context?: HttpContext): Observable<StrictHttpResponse<PageMessageDto>> {
    return getMessagesBySender(this.http, this.rootUrl, params, context);
  }

  /**
   * Récupérer les messages envoyés par un utilisateur.
   *
   * Récupérer les messages envoyés par un utilisateur
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getMessagesBySender$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMessagesBySender(params: GetMessagesBySender$Params, context?: HttpContext): Observable<PageMessageDto> {
    return this.getMessagesBySender$Response(params, context).pipe(
      map((r: StrictHttpResponse<PageMessageDto>): PageMessageDto => r.body)
    );
  }

  /** Path part for operation `searchMessages()` */
  static readonly SearchMessagesPath = '/gametracker/v1/message/search/{userId}';

  /**
   * Rechercher des messages dans l'historique d'un utilisateur.
   *
   * Rechercher des messages dans l'historique d'un utilisateur
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `searchMessages()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  searchMessages$Response(params: SearchMessages$Params, context?: HttpContext): Observable<StrictHttpResponse<PageMessageDto>> {
    return searchMessages(this.http, this.rootUrl, params, context);
  }

  /**
   * Rechercher des messages dans l'historique d'un utilisateur.
   *
   * Rechercher des messages dans l'historique d'un utilisateur
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `searchMessages$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  searchMessages(params: SearchMessages$Params, context?: HttpContext): Observable<PageMessageDto> {
    return this.searchMessages$Response(params, context).pipe(
      map((r: StrictHttpResponse<PageMessageDto>): PageMessageDto => r.body)
    );
  }

  /** Path part for operation `getRecentMessages()` */
  static readonly GetRecentMessagesPath = '/gametracker/v1/message/recent/{userId}';

  /**
   * Récupérer les messages récents d'un utilisateur.
   *
   * Récupérer les messages récents d'un utilisateur
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getRecentMessages()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  getRecentMessages$Response(params: GetRecentMessages$Params, context?: HttpContext): Observable<StrictHttpResponse<Array<MessageDto>>> {
    return getRecentMessages(this.http, this.rootUrl, params, context);
  }

  /**
   * Récupérer les messages récents d'un utilisateur.
   *
   * Récupérer les messages récents d'un utilisateur
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getRecentMessages$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  getRecentMessages(params: GetRecentMessages$Params, context?: HttpContext): Observable<Array<MessageDto>> {
    return this.getRecentMessages$Response(params, context).pipe(
      map((r: StrictHttpResponse<Array<MessageDto>>): Array<MessageDto> => r.body)
    );
  }

  /** Path part for operation `getMessagesByReceiver()` */
  static readonly GetMessagesByReceiverPath = '/gametracker/v1/message/receiver/{receiverId}';

  /**
   * Récupérer les messages reçus par un utilisateur.
   *
   * Récupérer les messages reçus par un utilisateur
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getMessagesByReceiver()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMessagesByReceiver$Response(params: GetMessagesByReceiver$Params, context?: HttpContext): Observable<StrictHttpResponse<PageMessageDto>> {
    return getMessagesByReceiver(this.http, this.rootUrl, params, context);
  }

  /**
   * Récupérer les messages reçus par un utilisateur.
   *
   * Récupérer les messages reçus par un utilisateur
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getMessagesByReceiver$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getMessagesByReceiver(params: GetMessagesByReceiver$Params, context?: HttpContext): Observable<PageMessageDto> {
    return this.getMessagesByReceiver$Response(params, context).pipe(
      map((r: StrictHttpResponse<PageMessageDto>): PageMessageDto => r.body)
    );
  }

  /** Path part for operation `getMessageHistory()` */
  static readonly GetMessageHistoryPath = '/gametracker/v1/message/history/{userId}';

  /**
   * Récupérer l'historique des messages d'un utilisateur.
   *
   * Récupérer l'historique des messages d'un utilisateur
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getMessageHistory()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  getMessageHistory$Response(params: GetMessageHistory$Params, context?: HttpContext): Observable<StrictHttpResponse<PageMessageDto>> {
    return getMessageHistory(this.http, this.rootUrl, params, context);
  }

  /**
   * Récupérer l'historique des messages d'un utilisateur.
   *
   * Récupérer l'historique des messages d'un utilisateur
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getMessageHistory$Response()` instead.
   *
   * This method sends `application/json` and handles request body of type `application/json`.
   */
  getMessageHistory(params: GetMessageHistory$Params, context?: HttpContext): Observable<PageMessageDto> {
    return this.getMessageHistory$Response(params, context).pipe(
      map((r: StrictHttpResponse<PageMessageDto>): PageMessageDto => r.body)
    );
  }

  /** Path part for operation `getConversation()` */
  static readonly GetConversationPath = '/gametracker/v1/message/conversation/{user1Id}/{user2Id}';

  /**
   * Récupérer la conversation entre deux utilisateurs.
   *
   * Récupérer la conversation entre deux utilisateurs
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `getConversation()` instead.
   *
   * This method doesn't expect any request body.
   */
  getConversation$Response(params: GetConversation$Params, context?: HttpContext): Observable<StrictHttpResponse<PageMessageDto>> {
    return getConversation(this.http, this.rootUrl, params, context);
  }

  /**
   * Récupérer la conversation entre deux utilisateurs.
   *
   * Récupérer la conversation entre deux utilisateurs
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `getConversation$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  getConversation(params: GetConversation$Params, context?: HttpContext): Observable<PageMessageDto> {
    return this.getConversation$Response(params, context).pipe(
      map((r: StrictHttpResponse<PageMessageDto>): PageMessageDto => r.body)
    );
  }

  /** Path part for operation `deleteConversation()` */
  static readonly DeleteConversationPath = '/gametracker/v1/message/conversation/{user1Id}/{user2Id}';

  /**
   * Supprimer une conversation entre deux utilisateurs.
   *
   * Supprimer une conversation entre deux utilisateurs
   *
   * This method provides access to the full `HttpResponse`, allowing access to response headers.
   * To access only the response body, use `deleteConversation()` instead.
   *
   * This method doesn't expect any request body.
   */
  deleteConversation$Response(params: DeleteConversation$Params, context?: HttpContext): Observable<StrictHttpResponse<void>> {
    return deleteConversation(this.http, this.rootUrl, params, context);
  }

  /**
   * Supprimer une conversation entre deux utilisateurs.
   *
   * Supprimer une conversation entre deux utilisateurs
   *
   * This method provides access only to the response body.
   * To access the full response (for headers, for example), `deleteConversation$Response()` instead.
   *
   * This method doesn't expect any request body.
   */
  deleteConversation(params: DeleteConversation$Params, context?: HttpContext): Observable<void> {
    return this.deleteConversation$Response(params, context).pipe(
      map((r: StrictHttpResponse<void>): void => r.body)
    );
  }

}
